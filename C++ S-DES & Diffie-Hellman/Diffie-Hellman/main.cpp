//
//  main.cpp
//  Diffie-Hellman
//
//  Created by Michael Giglio on 3/9/19.
//  Copyright Â© 2019 Michael Giglio. All rights reserved.
//

#include <iostream>
#include <cmath>
#include <ctime>
#include <cstdlib>
#include <set>

using namespace std;

/*
 * Methods that are used in this program.
 * They are explained down below
 */
void getUserInput(long long int& p,long long int& g,long long int& xa,long long int& xb);
void keyExchange(long long int p,long long int g,long long int xa,long long int xb);
void generateNumb(long long int& p,long long int& g,long long int& xa,long long int& xb);
bool isPrime(long long int p);
bool isPrimeRoot(long long int p,long long int g);
void primeFactor(set<long long int> &s,long long int phi);
long long int power(long long int g, unsigned long long int y,long long int p);
// end methods

// Main function
int main(int argc, const char * argv[]) {
    /*
     * This line ensures that the numbers generated by
     * are random every time.
     */
    srand(time(NULL));
    
    // Title.
    cout << "Diffie-Hellman Key Exchange" << endl << endl;
    
    /*
     * Allows the user to select if they want to manually
     * enter values or generate random numbers.
     * Makes sure that the choice entered is valid.
     */
    int choice = 0;
    while (choice < 1 || choice > 2) {
        cout << "Do you want to use: " << endl;
        cout << "1. Manual Input" << endl;
        cout << "2. Randomly Generated Input" << endl;
        
        cin >> choice;
        
        if (choice < 1 || choice > 2) {
            cout << "ERROR: Is not a valid choice" << endl;
        }
    }
    
    /*
     * Varaibles that are used in the porgram.
     * long long ints are used because when using int the powers
     * where sometimes so big that they turned negative.
     */
    long long int p, g, xa, xb;
    
    // Allows manual input or generates number based on choice
    if (choice == 1) {
        getUserInput(p,g,xa,xb);
    } else {
        generateNumb(p, g, xa, xb);
    }
    
    //Perform key exchange
    keyExchange(p,g,xa,xb);
}

/*
 * ----- getUserInput() -----
 *
 * -- Description
 * This function is used get the users input for the 4 variables
 * p, g, xa and xb
 *
 * -- Inputs
 * Four inputs are taken by this function:
 * $ The memory address of variable p.
 * $ The memory address of variable g.
 * $ The memory address of variable xa.
 * $ The memory address of variable xb.
 *
 * -- Outputs
 * This function outputs the four variables each storing numbers
 * defined by the user.
 */
void getUserInput(long long int& p,long long int& g,long long int& xa,long long int& xb) {
    
    /*
     * Do while loops to ensure that the values entered by user comply
     * with the rules for a Diffie-Hellman key exchange.
     *
     * p - has to be prime
     * g - has to be a primitive root of p
     * xa - must be a value from 0 to p-1
     * xb - must be a value from 0 to p-1
     */
    
    // Get p
    do {
        cout << "Enter a value p:";
        cin >> p;
    } while (p <= 1 || !isPrime(p));
    
    // Get g
    do {
        cout << "Enter a value g:";
        cin >> g;
    } while (g >= p || !isPrimeRoot(p, g));
    
    // Get xa
    do {
        cout << "Enter a value xa:";
        cin >> xa;
        
        if (xa < 0 || xa > (p-1)) {
            cout << "ERROR: xa must be 0 <= xa < p" << endl;
        }
    } while (xa < 0 || xa > (p-1));
    
    // Get xb
    do {
        cout << "Enter a value xb:";
        cin >> xb;
        
        if (xb < 0 || xb > (p-1)) {
            cout << "ERROR: xb must be 0 <= xa < p" << endl;
        }
    } while (xb < 0 || xb > (p-1));
}
// end getUserInput()

/*
 * ----- keyExchange() -----
 *
 * -- Description
 * This function is used to perform the key exchange using the
 * variables defined by the user or randomly generated
 *
 * -- Inputs
 * Four inputs are taken by this function:
 * $ The variable p.
 * $ The variable g.
 * $ The variable xa.
 * $ The variable xb.
 *
 * -- Outputs
 * This function outputs the four variables to the screen
 * $ The variable ya.
 * $ The variable yb.
 * $ The variable ka.
 * $ The variable kb..
 */
void keyExchange(long long int p,long long int g,long long int xa,long long int xb) {
    
    /*
     * Varaibles that are used in the porgram.
     * long long ints are used because when using int the powers
     * where sometimes so big that they turned negative.
     */
    long long int ya, yb, ka, kb;
    
    // ya = g^xa mod p
    ya = pow(g, xa);
    ya %= p;
    
    // yb = g^xb mod p
    yb = pow(g, xb);
    yb %= p;
    
    // ka = yb^xa mod p
    ka = pow(yb, xa);
    ka %= p;
    
    // ka = yb^xb mod p
    kb = pow(ya, xb);
    kb %= p;
    
    // Display the resutls
    cout << "ya = " << ya << endl;
    cout << "yb = " << yb << endl;
    cout << "ka = " << ka << endl;
    cout << "kb = " << kb << endl;
}
// end keyExchange()

/*
 * ----- generateNumb() -----
 *
 * -- Description
 * This function is similar to the getUsersInput() function except
 * p, g, xa and xb are randomly genereated using rand() while also
 * following the rules need to perform the Diffie-Hellman key exchange
 *
 * -- Inputs
 * Four inputs are taken by this function:
 * $ The memory address of variable p.
 * $ The memory address of variable g.
 * $ The memory address of variable xa.
 * $ The memory address of variable xb.
 *
 * -- Outputs
 * This function outputs the four variables each storing numbers
 * generated by rand.
 */
void generateNumb(long long int& p,long long int& g,long long int& xa,long long int& xb) {
    
    /*
     * Do while loops to ensure that the values entered by user comply
     * with the rules for a Diffie-Hellman key exchange.
     *
     * p - has to be prime
     * g - has to be a primitive root of p and g < p
     * xa - must be a value from 0 to p-1
     * xb - must be a value from 0 to p-1
     */
    
    // Generate p
    do {
        /* p is limited to numbers between 0 - 30 because
         * if it is too large it can cause issues with numbers
         * wrapping around to negatives.
         */
        p = (rand() % 30);
    } while (p <= 5 || !isPrime(p));
    
    // Generate g
    do {
        g = (rand() % p) + 2;
    } while (g >= p || !isPrimeRoot(p, g));
    
    // Generate xa
    do {
        xa = (rand() % p);
    } while (xa < 0 || xa > (p-1));
    
    // Generate xb
    do {
        xb = (rand() % p);
    } while (xb < 0 || xb > (p-1));
    
    // Display the resutls
    cout << "p = " << p << endl;
    cout << "g = " << g << endl;
    cout << "xa = " << xa << endl;
    cout << "xb = " << xb << endl;
}
// end generateNumb()

/*
 * ----- isPrime() -----
 *
 * -- Description
 * This function checks to see if the passed varaible
 * is a prime number.
 *
 * -- Inputs
 * One input is taken by this function:
 * $ The value of variable p.
 *
 * -- Outputs
 * This function returns false if p is not a prime
 * number and true if it is.
 */
bool isPrime(long long int p) {
    
    /*
     * for loop that checks number between 2 and p/2
     * to make sure that p is a prime number
     * if there isnt any remainder for one of the numbers
     * then p cannot be prime.
     *
     * NOTES:
     * $ i starts at 2 because 1 is a multiple of all numbers and anything
     * divided by 0 is undefined.
     * $ The loop runs to p/2 because of the axb = bxa rule for
     * multiplication.
     */
    for (int i = 2; i <= p/2; i++) {
        if (p % i == 0) {
            cout << "ERROR: " << p << " is not a prime number" << endl;
            return false;
        }
    }
    
    // Specify the number being used and then return true.
    cout << p << " is a prime number using " << p << endl << endl;
    return true;
}
// end isPrime()

/*
 * ----- isPrimeRoot() -----
 *
 * -- Description
 * This function checks to see if the passed varaible
 * is a primitive root of p
 *
 * -- Inputs
 * Two inputs are taken by this function:
 * $ The value of variable p.
 * $ The value of variable g.
 *
 * -- Outputs
 * This function returns false if p is not a primative root
 * and true if it is.
 *
 * -- NOTE
 * The below function was inspired by the solution posted on
 * the website GeeksforGeeks.
 *
 * The webpage is titled "Primitive root of a prime number n modulo n"
 * and is avaialble at
 * https://www.geeksforgeeks.org/primitive-root-of-a-prime-number-n-modulo-n/
 */
bool isPrimeRoot(long long int p,long long int g) {
    
    // Create a set to hold the prime factos of phi.
    set<long long int> s;
    
    // A boolean used to determine what to return.
    bool isRoot = true;
    
    // Calculate the value of phi.
    long long int phi = p-1;
    
    // Find all the prime factors of phi and store them in the set.
    primeFactor(s,phi);
    
    /*
     * Iterator that goes through the set and checks if
     * there is a power with value of 1.
     */
    for (auto it = s.begin(); it != s.end(); it++) {
        
        // Check if g^(phi/primefactors) mod n is equal to one.
        if (power(g, phi/(*it), p) == 1) {
            isRoot = false;
            break;
        }
    }
    
    // Return false if g is not a prime root or return true if it is.
    if (isRoot == false) {
        cout << "ERROR: " << g << " is not a primitive root" << endl;
        return false;
    } else {
        cout << g << " is a primitive root using " << g << endl << endl;
        return true;
    }
}
// end isPrimeRoot()

/*
 * ----- isPrimeRoot() -----
 *
 * -- Description
 * This function finds all the prime factors of a number
 * and stores them in a set
 *
 * -- Inputs
 * Two inputs are taken by this function:
 * $ The memory address of a set.
 * $ The value of variable phi.
 *
 * -- Outputs
 * This function fills the set with primitive roots
 *
 * -- NOTE
 * The below function was inspired by the solution posted on
 * the website GeeksforGeeks.
 *
 * The webpage is titled "Primitive root of a prime number n modulo n"
 * and is avaialble at
 * https://www.geeksforgeeks.org/primitive-root-of-a-prime-number-n-modulo-n/
 */
void primeFactor(set<long long int> &s,long long int phi) {
    
    /*
     * Insert the number 2 into the set everytime it divides into phi.
     * We can continually insert 2 into a set without an repercustions because
     * sets will automatically disreguard any duplicate value added to it.
     */
    while (phi%2 == 0) {
        s.insert(2);
        phi /= 2;
    }
    
    /*
     * phi must be odd that is why we +=2.
     * For each number in the for loop divide see if it
     * fits into phi with no remainder if it does store i in the set
     * divide phi by i and repeat.
     */
    for (int i = 3; i <= sqrt(phi); i += 2) {
        
        /* Continue to divide phi by i and store it in the set while the
         * remainder equals 0
         */
        while (phi%i == 0) {
            s.insert(i);
            phi /= i;
        }
    }
    
    // Used to handle a case when n is a prime number freater than two
    if(phi > 2)
        s.insert(phi);
}
//end primeFactor()

/*
 * ----- power() -----
 *
 * -- Description
 * This function calcualtes (g^n)%p
 *
 * -- Inputs
 * Three inputs are taken by this function:
 * $ The value of variable g.
 * $ The value of variable y.
 * $ The value of variable p.
 *
 * -- Outputs
 * This function returns (g^n)%p
 *
 * -- NOTE
 * The below function was inspired by the solution posted on
 * the website GeeksforGeeks.
 *
 * The webpage is titled "Primitive root of a prime number n modulo n"
 * and is avaialble at
 * https://www.geeksforgeeks.org/primitive-root-of-a-prime-number-n-modulo-n/
 */
long long int power(long long int g, unsigned long long int y,long long int p) {
    
    // Initialise the result
    long long int result = 1;
    
    // Update g if it is more than or equal to p
    g %= p;
    
    
    while (y > 0) {
        
        // If y is odd then multiply x with the result
        if (y%2 == 1) {
            result = (result * g) % p;
        }
        
        // y must be even now
        y /= 2;
        g = (g*g) % p;
    }
    
    return result;
}
// end power()
